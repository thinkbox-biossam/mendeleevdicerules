<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>쿼드랫 게임</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            box-sizing: border-box;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 1300px;
        }
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            width: 100%;
        }
        @media (min-width: 768px) {
            .main-content {
                flex-direction: row;
                justify-content: space-between;
                align-items: flex-start;
            }
        }
        .player-area {
            background-color: white;
            border-radius: 0.5rem;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 100%;
            margin-bottom: 1rem;
            transition: border 0.3s ease, box-shadow 0.3s ease;
        }
        @media (min-width: 768px) {
            .player-area {
                width: 300px; /* Slightly wider for more piece pool space */
                margin-bottom: 0;
            }
        }
        .player-area.active-player {
            border: 2px solid #f59e0b; /* Amber border for active player */
            box-shadow: 0 0 12px rgba(245, 158, 11, 0.6); /* Amber shadow */
        }
        .game-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* 4x4 grid */
            gap: 0.5rem;
            background-color: #cbd5e1; /* Slate-300 */
            padding: 0.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 480px; /* Max width for the board */
            aspect-ratio: 1 / 1; /* Maintain square shape */
            margin: 0 auto; /* Center the board in its container */
        }
        .quadrat {
            background-color: #e2e8f0; /* Slate-200 */
            border: 1px solid #94a3b8; /* Slate-400 */
            border-radius: 0.25rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 70px; /* Minimum height for quadrat */
            position: relative;
            padding: 0.25rem;
            overflow: visible; /* Allow parasites to visually overflow slightly */
            cursor: pointer;
        }
        .quadrat.selected-for-action { /* For card target quadrat */
            background-color: #fde047; /* Yellow-300 for card target */
            border-color: #facc15; /* Yellow-400 */
        }
        .quadrat.selected-for-placement { /* For placing a piece */
             outline: 3px dashed #2563eb; /* Blue dashed outline for placement target */
        }
         .quadrat .piece.selected-for-card-action { /* For selecting a piece for migration/parasitism host */
            outline: 3px solid #10b981; /* Emerald-500 solid outline for piece target */
            outline-offset: 2px;
        }

        .piece {
            width: 24px; /* Piece size */
            height: 24px;
            border-radius: 50%; /* Circular pieces */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem; /* Adaptation number font size */
            font-weight: bold;
            color: white; /* Adaptation number color */
            margin: 2px; /* Margin between pieces in a quadrat */
            position: relative;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2); /* Subtle shadow for depth */
            cursor: default; /* Default cursor, overridden by piece-pool-item or specific actions */
        }
        .piece.player1 { background-color: #3b82f6; } /* Player 1 color (Blue-500) */
        .piece.player2 { background-color: #ef4444; } /* Player 2 color (Red-500) */
        
        .piece.parasite {
            width: 18px; /* Smaller size for parasites */
            height: 18px;
            font-size: 0.6rem; /* Smaller font for parasite adaptation */
            border: 2px dashed white; /* Dashed border to distinguish parasites */
            position: absolute; /* Position relative to quadrat/host */
            top: -5px; /* Offset to appear on top of host */
            right: -5px;
            z-index: 10; /* Ensure parasite is above other pieces */
            box-shadow: 0 0 5px rgba(0,0,0,0.7); /* More distinct shadow for parasite */
        }
        .card {
            background-color: #f8fafc; /* Slate-50 */
            border: 1px solid #cbd5e1; /* Slate-300 */
            border-radius: 0.25rem;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            font-size: 0.8rem;
            transition: transform 0.1s ease;
        }
        .card:hover { transform: translateY(-2px); } /* Slight lift on hover */
        .card.selected {
            border-color: #2563eb; /* Blue-600 for selected card */
            background-color: #dbeafe; /* Blue-100 */
            transform: scale(1.05); /* Slightly larger when selected */
        }
        .card.dark { background-color: #475569; color: white; } /* Dark card (Slate-600) */
        .card.dark.selected { border-color: #1e293b; background-color: #334155; } /* Dark selected (Slate-800/700) */
        
        .controls, .info-log {
            background-color: white;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 600px; /* Max width for controls/log area */
            text-align: center;
        }
        button {
            background-color: #2563eb; /* Blue-600 */
            color: white;
            padding: 0.6rem 1.2rem; /* Button padding */
            border: none;
            border-radius: 0.375rem; /* md rounded corners */
            cursor: pointer;
            margin: 0.25rem;
            transition: background-color 0.2s, transform 0.1s;
            font-weight: 500; /* Medium font weight */
        }
        button:hover { 
            background-color: #1d4ed8; /* Darker blue on hover (Blue-700) */
            transform: translateY(-1px); /* Slight lift on hover */
        }
        button:disabled {
            background-color: #9ca3af; /* Gray-400 for disabled button */
            cursor: not-allowed;
            transform: none;
        }
        .hidden { display: none; } /* Utility class to hide elements */

        .piece-pool {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem; /* Reduced gap for more pieces */
            max-height: 150px; /* Limit height and allow scroll if needed */
            overflow-y: auto; /* Enable vertical scroll for piece pool */
            padding: 0.25rem;
            border: 1px solid #e5e7eb; /* Light border for pool area (Gray-200) */
            border-radius: 0.25rem;
        }
        .piece-pool-item {
            display: inline-flex; /* Use flex for centering content */
            align-items: center;
            justify-content: center;
            width: 28px; /* Fixed width for pool items */
            height: 28px; /* Fixed height for pool items */
            border: 1px solid #ccc; /* Default border */
            border-radius: 0.25rem;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.7rem; /* Smaller font for pool items */
            transition: background-color 0.2s, border-color 0.2s;
        }
        .piece-pool-item.on-board {
            background-color: #e5e7eb; /* Gray-200 if on board */
            color: #6b7280; /* Gray-500 text */
            cursor: not-allowed;
            opacity: 0.6; /* Dim if on board */
        }
         .piece-pool-item.out-of-play {
            background-color: #9ca3af; /* Gray-400 if out of play */
            color: #4b5563; /* Gray-600 text */
            text-decoration: line-through; /* Strike through if out of play */
            cursor: not-allowed;
            opacity: 0.4; /* Dim more if out of play */
        }
        .piece-pool-item.selected {
            border-color: #2563eb; /* Blue-600 border for selected */
            background-color: #dbeafe; /* Blue-100 background */
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75); /* Darker overlay for modals */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Ensure modal is on top */
            backdrop-filter: blur(3px); /* Frosted glass effect for background */
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 0.5rem;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2); /* Enhanced shadow for modal */
            max-width: 90%; /* Max width for responsiveness */
            width: 450px; /* Default width for modal */
        }
        .quadrat-pieces-container {
            display: flex;
            flex-wrap: wrap; /* Allow pieces to wrap within quadrat */
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            position: relative; /* For absolute positioning of parasites */
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-3xl font-bold text-center my-4 text-slate-700">쿼드랫 게임</h1>

        <div class="main-content">
            <div id="player1-area" class="player-area">
                <h2 class="text-xl font-semibold mb-2 text-blue-600">플레이어 1</h2>
                <div class="my-2">
                    <h3 class="text-md font-medium">말 선택 (적응도):</h3>
                    <div id="p1-piece-pool" class="piece-pool"></div>
                </div>
                <h3 class="text-md font-medium">카드 (<span id="p1-cards-in-hand">2</span>):</h3>
                <div id="p1-hand"></div>
                <p class="mt-2 text-sm">선택한 카드: <span id="p1-selected-card-display">-</span></p>
                <p class="text-sm">선택한 칸: <span id="p1-selected-quadrat-display">-</span></p>
                <p class="text-sm">선택한 말(카드용): <span id="p1-selected-piece-for-card-display">-</span></p>
            </div>

            <div id="game-board" class="game-board">
                </div>

            <div id="player2-area" class="player-area">
                <h2 class="text-xl font-semibold mb-2 text-red-600">플레이어 2</h2>
                 <div class="my-2">
                    <h3 class="text-md font-medium">말 선택 (적응도):</h3>
                    <div id="p2-piece-pool" class="piece-pool"></div>
                </div>
                <h3 class="text-md font-medium">카드 (<span id="p2-cards-in-hand">2</span>):</h3>
                <div id="p2-hand"></div>
                <p class="mt-2 text-sm">선택한 카드: <span id="p2-selected-card-display">-</span></p>
                <p class="text-sm">선택한 칸: <span id="p2-selected-quadrat-display">-</span></p>
                 <p class="text-sm">선택한 말(카드용): <span id="p2-selected-piece-for-card-display">-</span></p>
            </div>
        </div>

        <div class="controls">
            <h3 class="text-lg font-medium mb-2">게임 진행</h3>
            <p id="current-turn-phase" class="mb-2">플레이어 1, 말 놓기</p>
            <button id="confirm-selection-button">선택 완료</button>
            </div>

        <div id="info-log" class="info-log">
            <h3 class="text-lg font-medium mb-2">게임 로그</h3>
            <div id="log-messages" class="text-sm max-h-40 overflow-y-auto border border-slate-200 rounded p-2 bg-slate-50">
                </div>
        </div>
    </div>

    <div id="modal-overlay" class="modal-overlay hidden">
        <div class="modal-content">
            <h2 id="modal-title" class="text-xl font-bold mb-4">게임 알림</h2>
            <p id="modal-message" class="whitespace-pre-wrap mb-4"></p>
            <button id="modal-action-button" class="mt-4">확인</button>
        </div>
    </div>

    <script>
        // --- Constants and Game Setup ---
        const BOARD_SIZE = 4; 
        const PIECES_PER_PLAYER = 18; 
        const INITIAL_PIECE_ADAPTATIONS = [1,1,1,1, 2,2,2,2, 3,3,3, 4,4,4, 5,5, 6,6]; // As per user request
        const HAND_SIZE = 2;

        const CARD_DEFINITIONS = [
            { id: 'supremacy', name: '쟁패', type: 'bright', condition: '동일 칸', effectDesc: 'if Σ적응도_A != Σ적응도_B: 적응도합 낮은 쪽 모든 말 제거' },
            { id: 'predation', name: '포식', type: 'bright', condition: '동일 칸', effectDesc: '제거수 = 내 말 수; 상대 말 적응도 낮은 순으로 제거' },
            { id: 'mutualism', name: '상리공생', type: 'bright', condition: '동일 칸, 양측 말 존재', effectDesc: '각 플레이어 말 +1 (적응도 1)' },
            { id: 'commensalism', name: '편리공생', type: 'bright', condition: '동일 칸, 상대 말 존재', effectDesc: '내 말 +1 (적응도 1)' },
            { id: 'parasitism', name: '기생', type: 'bright', condition: '상대 말 위', effectDesc: '내 말을 상대 말 위에 올림; 숙주 제거 → 함께 제거' },
            { id: 'migration', name: '이주', type: 'dark', condition: '인접 칸 지정', effectDesc: '내 말 1개 선택 → 인접 칸 이동' },
            { id: 'hunt', name: '사냥', type: 'dark', condition: '동일 칸', effectDesc: '적응도 최저 말 1개 제거; 동점 → 상대 우선 제거' }
        ];

        let gameState = {}; // Global game state object

        // --- DOM Elements ---
        const gameBoardElement = document.getElementById('game-board');
        const p1HandElement = document.getElementById('p1-hand');
        const p2HandElement = document.getElementById('p2-hand');
        const p1PiecePoolElement = document.getElementById('p1-piece-pool');
        const p2PiecePoolElement = document.getElementById('p2-piece-pool');
        const currentTurnPhaseElement = document.getElementById('current-turn-phase');
        const confirmSelectionButton = document.getElementById('confirm-selection-button');
        const logMessagesElement = document.getElementById('log-messages');
        
        // Displays for selected items
        const p1SelectedCardDisplay = document.getElementById('p1-selected-card-display');
        const p1SelectedQuadratDisplay = document.getElementById('p1-selected-quadrat-display');
        const p1SelectedPieceForCardDisplay = document.getElementById('p1-selected-piece-for-card-display');
        const p2SelectedCardDisplay = document.getElementById('p2-selected-card-display');
        const p2SelectedQuadratDisplay = document.getElementById('p2-selected-quadrat-display');
        const p2SelectedPieceForCardDisplay = document.getElementById('p2-selected-piece-for-card-display');

        // Modal elements
        const modalOverlay = document.getElementById('modal-overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        let modalActionButton = document.getElementById('modal-action-button'); // Let, because it's replaced

        // --- Utility Functions ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function addLog(message) {
            const logEntry = document.createElement('p');
            logEntry.classList.add('mb-1', 'text-left'); // Styling for log messages
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logMessagesElement.prepend(logEntry); // Add new messages to the top
        }

        // Function to show modal for transitions or notifications
        function showTransitionModal(title, message, buttonText, nextActionFn) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            
            // Recreate the button to ensure old event listeners are removed
            const newButton = document.createElement('button');
            newButton.id = 'modal-action-button';
            newButton.classList.add('mt-4');
            newButton.textContent = buttonText;
            // Apply Tailwind classes for button styling
            newButton.className = 'mt-4 bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md transition-transform transform hover:translate-y-[-1px]';


            // Replace the old button with the new one
            modalActionButton.parentNode.replaceChild(newButton, modalActionButton);
            modalActionButton = newButton; // Update the reference

            modalActionButton.onclick = () => { // Assign new click handler
                modalOverlay.classList.add('hidden');
                if (nextActionFn) nextActionFn();
            };
            modalOverlay.classList.remove('hidden'); // Show the modal
        }


        // --- Game Initialization ---
        function initializeGame() {
            // 1. Initialize Board (empty quadrats)
            let board = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                board[r] = [];
                for (let c = 0; c < BOARD_SIZE; c++) {
                    board[r][c] = { pieces: [] }; 
                }
            }

            // 2. Initialize Deck (shuffle cards)
            let deck = [];
            CARD_DEFINITIONS.forEach(cardDef => {
                deck.push({...cardDef, uniqueId: crypto.randomUUID()}); // Add unique ID for tracking
                deck.push({...cardDef, uniqueId: crypto.randomUUID()});
            });
            shuffleArray(deck);

            // 3. Initialize Players
            const createPlayer = (id) => {
                const allPieces = INITIAL_PIECE_ADAPTATIONS.map((adapt, index) => ({
                    id: `p${id}_piece${index}`, // Unique ID for each piece
                    playerId: id,
                    adaptation: adapt,
                    isParasite: false, 
                    hostId: null,
                    onBoard: false, // True if currently on the game board
                    isOutOfPlay: false, // True if removed from game permanently
                    row: -1, col: -1 // Position if on board
                }));
                return {
                    id: id,
                    allPieces: allPieces, 
                    usedInitialPiecesCount: 0, // Counts initial pieces placed (for game end condition)
                    hand: [],
                    selectedCard: null, // Card selected by player
                    selectedQuadrat: null, // {r, c} for card target quadrat
                    selectedPieceToPlace: null, // { id, adaptation } from allPieces for initial placement
                    selectedPlacementQuadrat: null, // {r,c} for initial placement quadrat
                    selectedPieceForCardAction: null // ID of a piece ON THE BOARD for migration/parasitism target
                };
            };

            gameState = {
                board: board,
                deck: deck,
                player1: createPlayer(1),
                player2: createPlayer(2),
                currentPlayerId: 1, // Player 1 starts
                currentPhase: 'PLACE_PIECE', 
                turnNumber: 1,
                actionLog: [] // For potential future use (e.g., undo, replay)
            };

            drawInitialHands(); // Each player draws 2 cards
            updateUI(); // Render initial game state
            addLog("게임 시작! 플레이어 1의 말 놓기 차례입니다.");
        }

        function drawInitialHands() {
            for (let i = 0; i < HAND_SIZE; i++) {
                drawCard(gameState.player1);
                drawCard(gameState.player2);
            }
        }

        function drawCard(player) {
            if (player.hand.length < HAND_SIZE && gameState.deck.length > 0) {
                const card = gameState.deck.shift(); // Draw from top of deck
                player.hand.push(card);
            } else if (gameState.deck.length === 0) {
                addLog("덱에 카드가 없습니다!"); // Log if deck is empty
            }
        }

        // --- UI Update Functions ---
        function updateUI() {
            renderBoard();
            renderPlayerInfo(gameState.player1, p1PiecePoolElement, p1HandElement, p1SelectedCardDisplay, p1SelectedQuadratDisplay, p1SelectedPieceForCardDisplay);
            renderPlayerInfo(gameState.player2, p2PiecePoolElement, p2HandElement, p2SelectedCardDisplay, p2SelectedQuadratDisplay, p2SelectedPieceForCardDisplay);
            updateTurnPhaseDisplay();
            updateConfirmButtonState();
        }

        function renderBoard() {
            gameBoardElement.innerHTML = ''; // Clear previous board state
            const currentPlayer = gameState.currentPlayerId === 1 ? gameState.player1 : gameState.player2;

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const quadratDiv = document.createElement('div');
                    quadratDiv.classList.add('quadrat');
                    quadratDiv.dataset.r = r; // Store row/col for click events
                    quadratDiv.dataset.c = c;

                    // Highlight for piece placement selection
                    if (currentPlayer.selectedPlacementQuadrat && currentPlayer.selectedPlacementQuadrat.r === r && currentPlayer.selectedPlacementQuadrat.c === c) {
                        quadratDiv.classList.add('selected-for-placement');
                    }
                    // Highlight for card target quadrat selection
                    if (currentPlayer.selectedQuadrat && currentPlayer.selectedQuadrat.r === r && currentPlayer.selectedQuadrat.c === c) {
                        quadratDiv.classList.add('selected-for-action');
                    }

                    const piecesContainer = document.createElement('div');
                    piecesContainer.classList.add('quadrat-pieces-container');

                    const quadratData = gameState.board[r][c];
                    quadratData.pieces.forEach(piece => {
                        const pieceDiv = document.createElement('div');
                        pieceDiv.classList.add('piece', `player${piece.playerId}`);
                        pieceDiv.dataset.pieceId = piece.id; 
                        
                        // Show adaptation only for current player's pieces or during resolve/game over
                        if (piece.playerId === gameState.currentPlayerId || gameState.currentPhase === 'RESOLVE_CARDS' || gameState.currentPhase === 'GAME_OVER' || gameState.currentPlayerId === 0 /* Special ID for full reveal */) {
                            pieceDiv.textContent = piece.adaptation;
                        } else {
                            pieceDiv.textContent = '?'; // Hide opponent's adaptation
                        }

                        if (piece.isParasite) pieceDiv.classList.add('parasite');
                        
                        // Highlight piece selected for card action (migration source, parasitism host)
                        if (currentPlayer.selectedPieceForCardAction === piece.id) {
                            pieceDiv.classList.add('selected-for-card-action');
                        }
                        
                        // Add event listener for selecting a piece on the board for specific card actions
                        if ((gameState.currentPhase === 'SELECT_QUADRAT_FOR_CARD' && currentPlayer.selectedCard && (currentPlayer.selectedCard.id === 'migration' || currentPlayer.selectedCard.id === 'parasitism'))) {
                           pieceDiv.style.cursor = 'pointer'; 
                           pieceDiv.addEventListener('click', (e) => {
                               e.stopPropagation(); // Prevent quadrat click from firing as well
                               onBoardPieceClick(piece); // Handle click on a piece on the board
                           });
                        }
                        piecesContainer.appendChild(pieceDiv);
                    });
                    quadratDiv.appendChild(piecesContainer);
                    quadratDiv.addEventListener('click', () => onQuadratClick(r, c)); // Handle click on quadrat itself
                    gameBoardElement.appendChild(quadratDiv);
                }
            }
        }

        function renderPlayerInfo(player, piecePoolEl, handEl, selectedCardEl, selectedQuadratEl, selectedPieceForCardEl) {
            const playerAreaDiv = document.getElementById(`player${player.id}-area`);
            // Highlight active player's area
            playerAreaDiv.classList.toggle('active-player', player.id === gameState.currentPlayerId && gameState.currentPhase !== 'GAME_OVER');

            // Render Piece Pool: Show all 18 initial pieces, styled based on their status
            piecePoolEl.innerHTML = '';
            player.allPieces.sort((a,b) => a.adaptation - b.adaptation).forEach(p => { // Sort by adaptation for consistent display
                const pieceDiv = document.createElement('div');
                pieceDiv.classList.add('piece-pool-item');
                // Color piece pool item based on player
                if (player.id === 1) pieceDiv.classList.add('bg-blue-100', 'text-blue-700', 'border-blue-300');
                else pieceDiv.classList.add('bg-red-100', 'text-red-700', 'border-red-300');
                
                pieceDiv.textContent = p.adaptation;
                pieceDiv.dataset.pieceId = p.id;

                if (p.isOutOfPlay) pieceDiv.classList.add('out-of-play'); // Style if permanently removed
                else if (p.onBoard) pieceDiv.classList.add('on-board'); // Style if currently on the board
                
                // Highlight if selected for placement
                if (player.selectedPieceToPlace && player.selectedPieceToPlace.id === p.id) {
                    pieceDiv.classList.add('selected');
                }

                // Add click listener only if it's current player's turn to place, and piece is available
                if (gameState.currentPhase === 'PLACE_PIECE' && player.id === gameState.currentPlayerId && !p.onBoard && !p.isOutOfPlay) {
                    pieceDiv.addEventListener('click', () => onPiecePoolClick(player, p));
                } else {
                    pieceDiv.style.cursor = 'default'; // Not clickable
                }
                piecePoolEl.appendChild(pieceDiv);
            });

            // Render Hand: Show card details only for current player or during specific phases
            handEl.innerHTML = '';
            document.getElementById(`p${player.id}-cards-in-hand`).textContent = player.hand.length;
            if (player.id === gameState.currentPlayerId || gameState.currentPhase === 'GAME_OVER' || gameState.currentPhase === 'RESOLVE_CARDS' || gameState.currentPlayerId === 0) {
                player.hand.forEach(card => {
                    const cardDiv = document.createElement('div');
                    cardDiv.classList.add('card');
                    if (card.type === 'dark') cardDiv.classList.add('dark');
                    cardDiv.textContent = `${card.name} (${card.type === 'bright' ? '밝은' : '어두운'})`;
                    cardDiv.dataset.cardId = card.uniqueId; // Use unique ID for selection
                    
                    if (player.selectedCard && player.selectedCard.uniqueId === card.uniqueId) {
                        cardDiv.classList.add('selected');
                    }

                    // Add click listener only if it's current player's turn to select a card
                    if (gameState.currentPhase === 'SELECT_CARD' && player.id === gameState.currentPlayerId) {
                        cardDiv.addEventListener('click', () => onCardClick(player, card));
                    }
                    handEl.appendChild(cardDiv);
                });
            } else { // Opponent's turn, hide card details
                for (let i = 0; i < player.hand.length; i++) {
                    const cardDiv = document.createElement('div');
                    cardDiv.classList.add('card', 'bg-slate-200', 'text-slate-500'); // Generic hidden card style
                    cardDiv.textContent = `카드 ${i + 1}`;
                    handEl.appendChild(cardDiv);
                }
            }

            // Update display for selected card, quadrat, and piece for card action
            selectedCardEl.textContent = player.selectedCard ? player.selectedCard.name : '-';
            selectedQuadratEl.textContent = player.selectedQuadrat ? `(${player.selectedQuadrat.r}, ${player.selectedQuadrat.c})` : '-';
            const pieceForCard = player.allPieces.find(p => p.id === player.selectedPieceForCardAction);
            selectedPieceForCardEl.textContent = pieceForCard ? `말 ID ${pieceForCard.id} (적응도 ${pieceForCard.adaptation})` : '-';
        }

        function updateTurnPhaseDisplay() {
            let phaseText = `턴 ${gameState.turnNumber}, 플레이어 ${gameState.currentPlayerId}, `;
            const player = gameState.currentPlayerId === 1 ? gameState.player1 : gameState.player2;
            
            switch (gameState.currentPhase) {
                case 'PLACE_PIECE': phaseText += "말 놓기"; break;
                case 'SELECT_CARD': phaseText += "카드 선택"; break;
                case 'SELECT_QUADRAT_FOR_CARD': 
                    phaseText += `"${player.selectedCard ? player.selectedCard.name : ''}" 카드 적용 대상 선택`;
                    // Add more specific prompts for cards requiring multi-step selection
                    if (player.selectedCard?.id === 'migration' && !player.selectedPieceForCardAction) phaseText += " (이동할 자신의 말 클릭)";
                    else if (player.selectedCard?.id === 'migration' && player.selectedPieceForCardAction) phaseText += " (목표 칸 클릭)";
                    else if (player.selectedCard?.id === 'parasitism' && !player.selectedQuadrat) phaseText += " (상대 말 있는 칸 클릭)";
                    else if (player.selectedCard?.id === 'parasitism' && player.selectedQuadrat && !player.selectedPieceForCardAction) phaseText += " (숙주 말 클릭)";
                    else if (player.selectedCard && player.selectedCard.id !== 'migration' && player.selectedCard.id !== 'parasitism') phaseText += " (목표 칸 클릭)";
                    break;
                case 'RESOLVE_CARDS': phaseText = `턴 ${gameState.turnNumber}, 카드 효과 처리 중`; break;
                case 'BREEDING': phaseText = `턴 ${gameState.turnNumber}, 번식 단계`; break;
                case 'GAME_OVER': phaseText = "게임 종료"; break;
                default: phaseText += "알 수 없는 단계";
            }
            currentTurnPhaseElement.textContent = phaseText;
        }
        
        // Enable/disable confirm button based on current phase and selections
        function updateConfirmButtonState() {
            const player = gameState.currentPlayerId === 1 ? gameState.player1 : gameState.player2;
            let enabled = false;
            switch (gameState.currentPhase) {
                case 'PLACE_PIECE':
                    enabled = player.selectedPieceToPlace && player.selectedPlacementQuadrat;
                    break;
                case 'SELECT_CARD':
                    enabled = player.selectedCard;
                    break;
                case 'SELECT_QUADRAT_FOR_CARD':
                    if (player.selectedCard) {
                        if (player.selectedCard.id === 'migration') {
                            enabled = player.selectedPieceForCardAction && player.selectedQuadrat;
                        } else if (player.selectedCard.id === 'parasitism') {
                            enabled = player.selectedQuadrat && player.selectedPieceForCardAction;
                        } else { // For other cards, only quadrat selection is needed
                            enabled = player.selectedQuadrat;
                        }
                    }
                    break;
                default: enabled = false; // No confirm button for automated phases
            }
            confirmSelectionButton.disabled = !enabled;
            // Hide confirm button during automated phases
            confirmSelectionButton.classList.toggle('hidden', 
                gameState.currentPhase === 'RESOLVE_CARDS' || 
                gameState.currentPhase === 'BREEDING' ||
                gameState.currentPhase === 'GAME_OVER'
            );
        }

        // --- Event Handlers ---
        function onPiecePoolClick(player, pieceData) {
            if (gameState.currentPhase === 'PLACE_PIECE' && player.id === gameState.currentPlayerId) {
                if (pieceData.onBoard || pieceData.isOutOfPlay) {
                    showTransitionModal("선택 불가", "이미 사용되었거나 게임에서 제외된 말입니다.", "확인", null);
                    return;
                }
                player.selectedPieceToPlace = pieceData; // Store the selected piece data
                player.selectedPlacementQuadrat = null; // Reset quadrat selection if piece changes
                addLog(`플레이어 ${player.id}, (놓을 말) 적응도 ${pieceData.adaptation} (ID: ${pieceData.id}) 선택.`);
                updateUI();
            }
        }
        
        // Handle clicks on pieces already on the board (for migration source, parasitism host)
        function onBoardPieceClick(pieceData) {
            const player = gameState.currentPlayerId === 1 ? gameState.player1 : gameState.player2;
            if (gameState.currentPhase !== 'SELECT_QUADRAT_FOR_CARD' || !player.selectedCard) return;

            const cardId = player.selectedCard.id;
            if (cardId === 'migration') {
                if (pieceData.playerId === player.id && !pieceData.isParasite) { 
                    player.selectedPieceForCardAction = pieceData.id; // Store ID of piece to move
                    player.selectedQuadrat = null; // Reset target quadrat, player needs to select destination next
                    addLog(`플레이어 ${player.id}, (이주할 말) ID ${pieceData.id} 선택. 이제 목적지 칸을 선택하세요.`);
                } else {
                    showTransitionModal("선택 오류", "자신의 비기생 말만 이주할 수 있습니다.", "확인", null);
                }
            } else if (cardId === 'parasitism') {
                 // Parasitism: host selection happens on a piece within an already selected quadrat
                if (player.selectedQuadrat && pieceData.row === player.selectedQuadrat.r && pieceData.col === player.selectedQuadrat.c) {
                    if (pieceData.playerId !== player.id && !pieceData.isParasite) { 
                        player.selectedPieceForCardAction = pieceData.id; // Store ID of host piece
                        addLog(`플레이어 ${player.id}, (기생 숙주) ID ${pieceData.id} 선택.`);
                    } else {
                        showTransitionModal("선택 오류", "상대방의 비기생 말에만 기생할 수 있습니다.", "확인", null);
                    }
                } else {
                     // This case should ideally not be reached if UI flow guides quadrat selection first
                     addLog("기생: 먼저 칸을 선택한 후 해당 칸의 숙주 말을 선택하세요.");
                }
            }
            updateUI();
        }


        // Handle clicks on quadrats on the game board
        function onQuadratClick(r, c) {
            const player = gameState.currentPlayerId === 1 ? gameState.player1 : gameState.player2;
            
            switch(gameState.currentPhase) {
                case 'PLACE_PIECE': // Selecting quadrat to place a piece
                    if (player.selectedPieceToPlace) {
                        player.selectedPlacementQuadrat = { r, c }; // Store selected quadrat for placement
                        addLog(`플레이어 ${player.id}, 칸 (${r},${c})에 말 놓기 위치 선택.`);
                    } else {
                        showTransitionModal("알림", "먼저 놓을 말을 선택해주세요.", "확인", null);
                    }
                    break;
                case 'SELECT_QUADRAT_FOR_CARD': // Selecting quadrat for card effect
                    if (!player.selectedCard) return; 
                    const cardId = player.selectedCard.id;

                    if (cardId === 'migration') {
                        if (player.selectedPieceForCardAction) { // Source piece already selected, this click is for destination
                            const sourcePieceOriginalData = player.allPieces.find(p => p.id === player.selectedPieceForCardAction);
                            if (sourcePieceOriginalData && isAdjacent(sourcePieceOriginalData.row, sourcePieceOriginalData.col, r, c)) {
                                player.selectedQuadrat = {r,c}; // Store destination quadrat
                                addLog(`플레이어 ${player.id}, 이주 목적지 칸 (${r},${c}) 선택.`);
                            } else {
                                showTransitionModal("선택 오류", "선택한 말의 인접한 칸으로만 이주할 수 있습니다.", "확인", null);
                                player.selectedQuadrat = null; // Clear invalid selection
                            }
                        } else {
                            // Player needs to click their piece on board first for migration
                            addLog("이주: 먼저 보드 위에서 이동시킬 자신의 말을 클릭하세요.");
                        }
                    } else if (cardId === 'parasitism') {
                        // For parasitism, first click on quadrat selects the target quadrat.
                        // Second click (on a piece within that quadrat) selects the host.
                        if (!player.selectedQuadrat || (player.selectedQuadrat.r !==r || player.selectedQuadrat.c !==c) ) { 
                            const quadratHasOpponentPiece = gameState.board[r][c].pieces.some(p => p.playerId !== player.id && !p.isParasite);
                            if (quadratHasOpponentPiece) {
                                player.selectedQuadrat = {r,c}; // Store target quadrat
                                player.selectedPieceForCardAction = null; // Reset host selection, needs to be picked next
                                addLog(`플레이어 ${player.id}, 기생 대상 칸 (${r},${c}) 선택. 이제 해당 칸에서 숙주 말을 클릭하세요.`);
                            } else {
                                showTransitionModal("선택 오류", "상대방의 비기생 말이 있는 칸을 선택해야 합니다.", "확인", null);
                            }
                        } // If quadrat is already selected, clicks on pieces are handled by onBoardPieceClick
                    } else { // For other cards, this click directly selects the target quadrat
                        player.selectedQuadrat = { r, c };
                        addLog(`플레이어 ${player.id}, 카드 "${player.selectedCard.name}" 대상으로 칸 (${r},${c}) 선택.`);
                    }
                    break;
            }
            updateUI();
        }

        // Handle clicks on cards in hand
        function onCardClick(player, card) {
             if (gameState.currentPhase === 'SELECT_CARD' && player.id === gameState.currentPlayerId) {
                player.selectedCard = card; // Store selected card
                player.selectedQuadrat = null; // Reset quadrat selection when card changes
                player.selectedPieceForCardAction = null; // Reset piece selection for card action
                addLog(`플레이어 ${player.id}, 카드 "${card.name}" 선택.`);
                updateUI();
            }
        }
        
        confirmSelectionButton.addEventListener('click', () => {
            handleConfirmSelection(); // Main action confirmation logic
        });

        // --- Game Logic Flow ---
        function handleConfirmSelection() {
            const player = gameState.currentPlayerId === 1 ? gameState.player1 : gameState.player2;
            const opponent = gameState.currentPlayerId === 1 ? gameState.player2 : gameState.player1;

            switch (gameState.currentPhase) {
                case 'PLACE_PIECE':
                    if (player.selectedPieceToPlace && player.selectedPlacementQuadrat) {
                        const placedSuccessfully = placePiece(player, player.selectedPieceToPlace, player.selectedPlacementQuadrat);
                        if (placedSuccessfully) {
                            player.selectedPieceToPlace = null;
                            player.selectedPlacementQuadrat = null;
                            
                            if (gameState.currentPlayerId === 1) { // Player 1 just placed
                                showTransitionModal("턴 종료", "플레이어 1이 말 배치를 완료했습니다.\n플레이어 2에게 기기를 넘겨주세요.", "플레이어 2 턴 시작", () => {
                                    gameState.currentPlayerId = 2; // Switch to Player 2
                                    addLog("플레이어 2의 말 놓기 차례입니다.");
                                    updateUI();
                                });
                            } else { // Player 2 just placed, end of piece placement phase for the turn
                                 showTransitionModal("말 놓기 완료", "양쪽 플레이어 말 놓기 완료.\n플레이어 1에게 기기를 넘겨 카드 선택을 준비하세요.", "플레이어 1 카드 선택 시작", () => {
                                    gameState.currentPlayerId = 1; // Back to Player 1
                                    gameState.currentPhase = 'SELECT_CARD'; // Move to card selection phase
                                    addLog("플레이어 1의 카드 선택 차례입니다.");
                                    updateUI();
                                });
                            }
                        } // If placement failed, modal already shown by placePiece, UI updated.
                    } else { showTransitionModal("선택 오류", "놓을 말과 칸을 모두 선택해주세요.", "확인", null); }
                    break;

                case 'SELECT_CARD':
                    if (player.selectedCard) {
                        if (gameState.currentPlayerId === 1) { // Player 1 just selected card
                             showTransitionModal("카드 선택 완료", `플레이어 1이 카드 "${player.selectedCard.name}"을(를) 선택했습니다.\n플레이어 2에게 기기를 넘겨주세요.`, "플레이어 2 카드 선택 시작", () => {
                                gameState.currentPlayerId = 2; // Switch to Player 2
                                addLog("플레이어 2의 카드 선택 차례입니다.");
                                updateUI();
                            });
                        } else { // Player 2 just selected card, end of card selection phase
                            showTransitionModal("카드 선택 완료", `플레이어 2가 카드 "${player.selectedCard.name}"을(를) 선택했습니다.\n플레이어 1에게 기기를 넘겨 칸 선택을 준비하세요.`, "플레이어 1 칸 선택 시작", () => {
                                gameState.currentPlayerId = 1; // Back to Player 1
                                gameState.currentPhase = 'SELECT_QUADRAT_FOR_CARD'; // Move to quadrat selection for card
                                addLog(`플레이어 1, 카드 "${gameState.player1.selectedCard.name}"을(를) 적용할 대상을 선택하세요.`);
                                updateUI();
                            });
                        }
                    } else { showTransitionModal("선택 오류", "카드를 선택해주세요.", "확인", null); }
                    break;

                case 'SELECT_QUADRAT_FOR_CARD':
                    // Validation for card target selection is handled by enabling the confirm button
                    if (gameState.currentPlayerId === 1) { // Player 1 just selected target for their card
                        addLog(`플레이어 1, 카드 "${player.selectedCard.name}" 대상 선택 완료.`);
                        showTransitionModal("대상 선택 완료", `플레이어 1이 카드 "${player.selectedCard.name}"의 대상을 선택했습니다.\n플레이어 2에게 기기를 넘겨주세요.`, "플레이어 2 칸 선택 시작", () => {
                            gameState.currentPlayerId = 2; // Switch to Player 2
                            addLog(`플레이어 2, 카드 "${gameState.player2.selectedCard.name}"을(를) 적용할 대상을 선택하세요.`);
                            updateUI();
                        });
                    } else { // Player 2 just selected target for their card, end of selection phase
                        addLog(`플레이어 2, 카드 "${player.selectedCard.name}" 대상 선택 완료.`);
                        addLog("양쪽 플레이어 카드 및 대상 칸 선택 완료. 카드 효과를 처리합니다.");
                        gameState.currentPhase = 'RESOLVE_CARDS'; // Move to card resolution
                        resolveAndApplyCards(); // This will handle UI updates and further transitions
                    }
                    break;
            }
            // updateUI is generally called within the modal's nextActionFn or after the main logic
        }

        // Place a selected piece from player's pool onto the board
        function placePiece(player, pieceDataFromPool, quadratCoords) {
            const { r, c } = quadratCoords;
            const quadrat = gameState.board[r][c];
            const pieceToPlace = player.allPieces.find(p => p.id === pieceDataFromPool.id); 

            if (!pieceToPlace || pieceToPlace.onBoard || pieceToPlace.isOutOfPlay) {
                addLog(`오류: 말 ID ${pieceDataFromPool.id}을(를) 놓을 수 없습니다 (상태 오류).`);
                showTransitionModal("오류", `말 ID ${pieceDataFromPool.id}을(를) 놓을 수 없습니다 (상태 오류).`, "확인", null);
                return false; 
            }

            const nonParasiteCount = quadrat.pieces.filter(p => !p.isParasite).length;
            if (nonParasiteCount >= 4) { // Max 4 non-parasite pieces per quadrat
                showTransitionModal("배치 불가", "이 칸에는 더 이상 말을 놓을 수 없습니다 (최대 4개 비기생 말).", "확인", null);
                return false; 
            }
            
            // Update piece state in the player's master list
            pieceToPlace.onBoard = true;
            pieceToPlace.row = r;
            pieceToPlace.col = c;
            quadrat.pieces.push({...pieceToPlace}); // Add a *copy* of the piece to the board quadrat
            player.usedInitialPiecesCount++; // Increment count for game end condition
            addLog(`플레이어 ${player.id}, 칸 (${r},${c})에 적응도 ${pieceToPlace.adaptation} (ID: ${pieceToPlace.id}) 말 배치.`);
            return true; 
        }
        
        // Resolve and apply effects of selected cards
        function resolveAndApplyCards() {
            addLog("--- 카드 효과 처리 시작 ---");
            const p1 = gameState.player1;
            const p2 = gameState.player2;

            const originalPlayerId = gameState.currentPlayerId;
            gameState.currentPlayerId = 0; // Temporarily set to reveal all adaptations
            updateUI(); 

            // Log selected cards and targets
            addLog(`플레이어 1: 카드 '${p1.selectedCard.name}' -> 칸 (${p1.selectedQuadrat.r}, ${p1.selectedQuadrat.c})` + (p1.selectedPieceForCardAction ? `, 대상 말 ID: ${p1.selectedPieceForCardAction}` : ''));
            addLog(`플레이어 2: 카드 '${p2.selectedCard.name}' -> 칸 (${p2.selectedQuadrat.r}, ${p2.selectedQuadrat.c})` + (p2.selectedPieceForCardAction ? `, 대상 말 ID: ${p2.selectedPieceForCardAction}` : ''));

            const p1TargetQuad = p1.selectedQuadrat;
            const p2TargetQuad = p2.selectedQuadrat;

            // Apply card effects based on conflict rules
            if (p1TargetQuad.r !== p2TargetQuad.r || p1TargetQuad.c !== p2TargetQuad.c) { // Different quadrats
                addLog("다른 칸 지정: 플레이어 1(선) 카드 먼저 처리, 그 후 플레이어 2 카드 처리.");
                applyCardEffect(p1, p1.selectedCard, p1TargetQuad, p1.selectedPieceForCardAction);
                updateUI(); // Update UI after P1's card effect
                applyCardEffect(p2, p2.selectedCard, p2TargetQuad, p2.selectedPieceForCardAction);
            } else { // Same quadrat
                addLog(`같은 칸 (${p1TargetQuad.r}, ${p1TargetQuad.c}) 지정됨. 충돌 규칙 적용.`);
                const commonQuadrat = gameState.board[p1TargetQuad.r][p1TargetQuad.c]; // Reference to the quadrat's pieces array
                if (p1.selectedCard.type === 'bright' && p2.selectedCard.type === 'bright') {
                    addLog("둘 다 밝은 색 카드: 칸 내 말들의 적응도 합 비교 (비기생 말 대상).");
                    const sumAdaptP1 = commonQuadrat.pieces.filter(p => p.playerId === 1 && !p.isParasite).reduce((sum, piece) => sum + piece.adaptation, 0);
                    const sumAdaptP2 = commonQuadrat.pieces.filter(p => p.playerId === 2 && !p.isParasite).reduce((sum, piece) => sum + piece.adaptation, 0);
                    addLog(`칸 내 P1 적응도 합: ${sumAdaptP1}, P2 적응도 합: ${sumAdaptP2}`);
                    if (sumAdaptP1 > sumAdaptP2) {
                        addLog("플레이어 1 적응도 합이 높아 플레이어 1 카드만 발동.");
                        applyCardEffect(p1, p1.selectedCard, p1TargetQuad, p1.selectedPieceForCardAction);
                    } else if (sumAdaptP2 > sumAdaptP1) {
                        addLog("플레이어 2 적응도 합이 높아 플레이어 2 카드만 발동.");
                        applyCardEffect(p2, p2.selectedCard, p2TargetQuad, p2.selectedPieceForCardAction);
                    } else {
                        addLog("적응도 합 동점. 아무 카드도 발동되지 않음.");
                    }
                } else if (p1.selectedCard.type === 'dark' && p2.selectedCard.type === 'dark') {
                    addLog("둘 다 어두운 색 카드: 플레이어 1(선) 카드 먼저 처리, 그 후 플레이어 2 카드 처리.");
                    applyCardEffect(p1, p1.selectedCard, p1TargetQuad, p1.selectedPieceForCardAction);
                    updateUI(); 
                    applyCardEffect(p2, p2.selectedCard, p2TargetQuad, p2.selectedPieceForCardAction);
                } else { // Bright + Dark
                    addLog("밝은 색 + 어두운 색 카드: 어두운 카드 먼저 처리, 그 후 밝은 카드 처리.");
                    if (p1.selectedCard.type === 'dark') {
                        applyCardEffect(p1, p1.selectedCard, p1TargetQuad, p1.selectedPieceForCardAction);
                        updateUI(); 
                        applyCardEffect(p2, p2.selectedCard, p2TargetQuad, p2.selectedPieceForCardAction); 
                    } else { // P2's card is dark
                        applyCardEffect(p2, p2.selectedCard, p2TargetQuad, p2.selectedPieceForCardAction);
                        updateUI(); 
                        applyCardEffect(p1, p1.selectedCard, p1TargetQuad, p1.selectedPieceForCardAction);
                    }
                }
            }
            
            gameState.currentPlayerId = originalPlayerId; // Restore current player ID
            addLog("--- 카드 효과 처리 완료 ---");
            updateUI(); 
            
            replenishCardsAndEndCardPhase(); // Proceed to replenish cards and next phase
        }
        
        // Replenish hands, discard used cards, and move to next phase (breeding or game over)
        function replenishCardsAndEndCardPhase() {
            const p1 = gameState.player1;
            const p2 = gameState.player2;

            // Return used cards to the bottom of the deck and draw new ones
            if (p1.selectedCard) {
                gameState.deck.push(p1.selectedCard); 
                p1.hand = p1.hand.filter(c => c.uniqueId !== p1.selectedCard.uniqueId);
                drawCard(p1);
            }
            if (p2.selectedCard) {
                gameState.deck.push(p2.selectedCard);
                p2.hand = p2.hand.filter(c => c.uniqueId !== p2.selectedCard.uniqueId);
                drawCard(p2);
            }

            // Reset selections for the next turn
            p1.selectedCard = null; p1.selectedQuadrat = null; p1.selectedPieceForCardAction = null;
            p2.selectedCard = null; p2.selectedQuadrat = null; p2.selectedPieceForCardAction = null;
            
            addLog("카드 사용 및 보충 완료.");
            
            if (checkGameOver()) { // Check if game end condition is met
                gameState.currentPhase = 'GAME_OVER';
                addLog("게임 종료 조건 충족!");
                updateUI(); 
                showTransitionModal("게임 종료", "모든 플레이어가 말을 소진했습니다. 결과를 확인합니다.", "결과 보기", () => {
                    displayGameResults();
                });
            } else { // Proceed to breeding phase
                gameState.currentPhase = 'BREEDING';
                addLog("번식 단계로 이동합니다.");
                updateUI(); 
                showTransitionModal("번식 단계", "번식 단계를 진행합니다.", "확인", () => {
                     performBreeding(); 
                });
            }
        }

        // Apply the effect of a single card
        function applyCardEffect(player, card, targetQuadratCoords, selectedPieceIdOnBoard) {
            const { r, c } = targetQuadratCoords;
            const quadrat = gameState.board[r][c]; // This is a reference to the quadrat object
            const opponentId = player.id === 1 ? 2 : 1;
            const opponent = player.id === 1 ? gameState.player2 : gameState.player1; // Get opponent player object
            addLog(`플레이어 ${player.id}의 카드 '${card.name}' 효과 발동 (칸: ${r},${c}).`);

            switch (card.id) {
                case 'supremacy': 
                    const sumAdaptP = quadrat.pieces.filter(p => p.playerId === player.id && !p.isParasite).reduce((sum, piece) => sum + piece.adaptation, 0);
                    const sumAdaptOpp = quadrat.pieces.filter(p => p.playerId === opponentId && !p.isParasite).reduce((sum, piece) => sum + piece.adaptation, 0);
                    if (sumAdaptP !== sumAdaptOpp) {
                        const loserId = sumAdaptP < sumAdaptOpp ? player.id : opponentId;
                        addLog(`쟁패: 플레이어 ${loserId}의 모든 비기생 말이 칸 (${r},${c})에서 제거됩니다.`);
                        // Filter out loser's pieces from the quadrat's pieces array
                        quadrat.pieces = quadrat.pieces.filter(p => {
                            if (p.playerId === loserId && !p.isParasite) {
                                removePieceFromGame(p); // Mark as out of play in master list
                                return false; // Remove from quadrat.pieces
                            }
                            return true;
                        });
                    } else { addLog("쟁패: 적응도 합(비기생)이 같아 효과 없음."); }
                    break;
                case 'predation': 
                    const myPieceCount = quadrat.pieces.filter(p => p.playerId === player.id && !p.isParasite).length;
                    if (myPieceCount === 0) {
                        addLog("포식: 내 비기생 말이 없어 효과 없음."); break;
                    }
                    let opponentPieces = quadrat.pieces.filter(p => p.playerId === opponentId && !p.isParasite);
                    opponentPieces.sort((a, b) => a.adaptation - b.adaptation); // Sort by lowest adaptation
                    
                    let removedCount = 0;
                    for (let i = 0; i < Math.min(myPieceCount, opponentPieces.length); i++) {
                        const pieceToRemove = opponentPieces[i];
                        addLog(`포식: 상대 말(ID: ${pieceToRemove.id}, 적응도: ${pieceToRemove.adaptation}) 제거.`);
                        removePieceFromGame(pieceToRemove); 
                        quadrat.pieces = quadrat.pieces.filter(p => p.id !== pieceToRemove.id); 
                        removedCount++;
                    }
                    if(removedCount === 0) addLog("포식: 제거할 상대 말이 없거나 내 말이 없음.");
                    break;
                case 'mutualism': 
                    if (quadrat.pieces.some(p => p.playerId === player.id && !p.isParasite) && quadrat.pieces.some(p => p.playerId === opponentId && !p.isParasite)) {
                        addLog("상리공생: 양 플레이어 말 +1 (적응도 1).");
                        addPieceToBoardFromPool(player, 1, r, c, false); // Add piece for current player
                        addPieceToBoardFromPool(opponent, 1, r, c, false); // Add piece for opponent
                    } else { addLog("상리공생: 양측 플레이어의 비기생 말이 모두 존재하지 않아 효과 없음."); }
                    break;
                case 'commensalism': 
                    if (quadrat.pieces.some(p => p.playerId === opponentId && !p.isParasite)) {
                        addLog("편리공생: 내 말 +1 (적응도 1).");
                        addPieceToBoardFromPool(player, 1, r, c, false);
                    } else { addLog("편리공생: 상대방 비기생 말이 없어 효과 없음."); }
                    break;
                case 'parasitism':
                    // selectedPieceIdOnBoard is the ID of the host piece
                    const hostPiece = quadrat.pieces.find(p => p.id === selectedPieceIdOnBoard && p.playerId === opponentId && !p.isParasite);
                    if (hostPiece) {
                        addLog(`기생: 내 말을 상대 말(ID: ${hostPiece.id}) 위에 올림 (적응도 1 기생 말).`);
                        addPieceToBoardFromPool(player, 1, r, c, true, hostPiece.id); // Add a parasite piece
                    } else { addLog(`기생: 유효한 숙주(ID: ${selectedPieceIdOnBoard})를 찾지 못했거나, 해당 말은 기생 대상이 될 수 없습니다.`); }
                    break;
                case 'migration':
                    // selectedPieceIdOnBoard is the ID of the piece to move
                    const pieceToMoveOnBoard = quadrat.pieces.find(p => p.id === selectedPieceIdOnBoard && p.playerId === player.id); // Find the piece on its current quadrat
                    const pieceToMoveOriginalData = player.allPieces.find(p => p.id === selectedPieceIdOnBoard); // Find in player's master list

                    if (!pieceToMoveOnBoard || !pieceToMoveOriginalData) {
                        addLog(`이주: 이동할 말(ID: ${selectedPieceIdOnBoard})을 현재 칸에서 찾을 수 없음.`);
                        // This might happen if the piece was removed by another card effect before this one resolved.
                        // Or if selectedPieceIdOnBoard was for a piece not in the targetQuadrat (which is source for migration)
                        // The targetQuadratCoords for migration is the DESTINATION. The piece is at its own (source) quadrat.
                        // Let's re-fetch the source quadrat based on pieceToMoveOriginalData
                        if (!pieceToMoveOriginalData || !pieceToMoveOriginalData.onBoard) {
                             addLog(`이주: 이동할 말(ID: ${selectedPieceIdOnBoard})을 찾을 수 없거나 보드 위에 없음.`);
                             break;
                        }
                        const sourceR = pieceToMoveOriginalData.row;
                        const sourceC = pieceToMoveOriginalData.col;
                        const sourceQuadrat = gameState.board[sourceR][sourceC];
                        
                        const destinationR = targetQuadratCoords.r; 
                        const destinationC = targetQuadratCoords.c;

                        const destQuadrat = gameState.board[destinationR][destinationC];
                        const nonParasiteCountDest = destQuadrat.pieces.filter(p => !p.isParasite).length;
                        if (nonParasiteCountDest >= 4 && !pieceToMoveOriginalData.isParasite) {
                            addLog(`이주: 목적지 칸 (${destinationR},${destinationC})이 가득 차 비기생 말 이동 불가.`);
                            break;
                        }
                        // Remove from source quadrat's pieces array
                        sourceQuadrat.pieces = sourceQuadrat.pieces.filter(p => p.id !== pieceToMoveOriginalData.id);
                        // Update piece's coordinates in the player's master list
                        pieceToMoveOriginalData.row = destinationR;
                        pieceToMoveOriginalData.col = destinationC;
                        // Add to destination quadrat's pieces array (a copy from the updated master list)
                        destQuadrat.pieces.push({...pieceToMoveOriginalData}); 
                        addLog(`이주: 플레이어 ${player.id}의 말(ID: ${pieceToMoveOriginalData.id})을 (${sourceR},${sourceC})에서 (${destinationR},${destinationC})로 이동.`);

                    } else {
                        // This block would be if selectedPieceIdOnBoard was expected to be in targetQuadratCoords, which is not the case for migration's destination.
                        // The logic above correctly handles finding the piece from its original location.
                    }
                    break;
                case 'hunt': 
                    if (quadrat.pieces.length === 0) { addLog("사냥: 칸에 말이 없어 효과 없음."); break; }
                    // Hunt targets non-parasite pieces
                    let allPiecesSorted = [...quadrat.pieces].filter(p => !p.isParasite).sort((a,b) => {
                        if (a.adaptation === b.adaptation) return a.playerId === opponentId ? -1 : 1; // Opponent first in tie
                        return a.adaptation - b.adaptation; // Sort by lowest adaptation
                    });
                    if (allPiecesSorted.length === 0) { addLog("사냥: 칸에 비기생 말이 없어 효과 없음."); break;}
                    const pieceToHunt = allPiecesSorted[0];
                    addLog(`사냥: 적응도 최저 비기생 말(ID: ${pieceToHunt.id}, 적응도: ${pieceToHunt.adaptation}, 주인: P${pieceToHunt.playerId}) 제거.`);
                    removePieceFromGame(pieceToHunt); 
                    quadrat.pieces = quadrat.pieces.filter(p => p.id !== pieceToHunt.id); 
                    break;
            }
            checkAllParasites(); // Check for and remove any parasites whose hosts are gone
        }

        // Check if two quadrats are adjacent
        function isAdjacent(r1, c1, r2, c2) {
            const dr = Math.abs(r1 - r2);
            const dc = Math.abs(c1 - c2);
            return (dr === 1 && dc === 0) || (dr === 0 && dc === 1); // Manhattan distance of 1
        }

        // Adds a new piece (from player's initial unplaced pool) to the board, used by cards/breeding
        function addPieceToBoardFromPool(player, adaptation, r, c, isParasite = false, hostId = null) {
            const quadrat = gameState.board[r][c];
            const nonParasiteCount = quadrat.pieces.filter(p => !p.isParasite).length;

            if (!isParasite && nonParasiteCount >= 4) { // Check quadrat capacity for non-parasites
                addLog(`칸 (${r},${c})에 비기생 말 추가 불가 (최대 4개).`);
                return null;
            }

            // Find an available piece of the specified adaptation from the player's master list
            const pieceFromInitialSet = player.allPieces.find(p => 
                p.adaptation === adaptation && 
                !p.onBoard &&  // Not already on the board
                !p.isOutOfPlay // Not permanently removed from game
            );

            if (!pieceFromInitialSet) {
                 addLog(`플레이어 ${player.id}, 적응도 ${adaptation} 말을 새로 놓을 수 없음 (사용 가능한 초기 말 없음).`);
                 return null;
            }
            
            // Update piece state in the player's master list
            pieceFromInitialSet.onBoard = true;
            pieceFromInitialSet.row = r;
            pieceFromInitialSet.col = c;
            pieceFromInitialSet.isParasite = isParasite; 
            pieceFromInitialSet.hostId = hostId;       
            
            const newBoardPiece = {...pieceFromInitialSet}; // Add a *copy* to the board quadrat's pieces array
            quadrat.pieces.push(newBoardPiece);
            
            // Increment usedInitialPiecesCount only for non-parasite pieces from the initial set
            // Parasites created by the '기생' card are also from the initial set but their placement logic is specific.
            // Breeding also uses initial set pieces.
            if (!isParasite) { 
                player.usedInitialPiecesCount++;
            }
            
            addLog(`플레이어 ${player.id}, 칸 (${r},${c})에 적응도 ${adaptation} (ID: ${newBoardPiece.id}) 말 추가 (${isParasite ? '기생' : '일반'}).`);
            return newBoardPiece;
        }
        
        // Mark a piece as permanently removed from the game (updates player's master list)
        function removePieceFromGame(pieceToRemoveData) { // pieceToRemoveData is the piece object from the board
            const owner = pieceToRemoveData.playerId === 1 ? gameState.player1 : gameState.player2;
            const originalPieceInPool = owner.allPieces.find(p => p.id === pieceToRemoveData.id);

            if (originalPieceInPool) {
                originalPieceInPool.onBoard = false; // No longer on the board
                originalPieceInPool.isOutOfPlay = true; // Permanently out of play
                originalPieceInPool.row = -1; // Reset position
                originalPieceInPool.col = -1;
                // usedInitialPiecesCount was already incremented when it was first placed.
                // It represents a piece from the initial 18 that has been "used up".
            }
            addLog(`말 ID ${pieceToRemoveData.id} (플레이어 ${pieceToRemoveData.playerId}, 적응도 ${pieceToRemoveData.adaptation}) 게임에서 완전히 제거됨.`);
        }

        // Check all quadrats for parasites whose hosts have been removed
        function checkAllParasites() {
            gameState.board.forEach((rowArr, r_idx) => {
                rowArr.forEach((quadrat, c_idx) => {
                    const initialPieceCountInQuadrat = quadrat.pieces.length;
                    quadrat.pieces = quadrat.pieces.filter(p_on_board => { // Iterate over pieces currently on this quadrat
                        if (p_on_board.isParasite) {
                            // Check if its host still exists ON THIS QUADRAT
                            const hostExists = quadrat.pieces.some(host => host.id === p_on_board.hostId && !host.isParasite);
                            if (!hostExists) {
                                addLog(`숙주 부재로 칸 (${r_idx},${c_idx})의 기생충(ID: ${p_on_board.id}) 제거.`);
                                // Mark the parasite as outOfPlay in its owner's master list
                                const parasiteOwner = p_on_board.playerId === 1 ? gameState.player1 : gameState.player2;
                                const originalParasiteInPool = parasiteOwner.allPieces.find(op => op.id === p_on_board.id);
                                if (originalParasiteInPool) { 
                                    originalParasiteInPool.onBoard = false;
                                    originalParasiteInPool.isOutOfPlay = true; 
                                }
                                return false; // Remove from quadrat.pieces
                            }
                        }
                        return true;
                    });
                });
            });
        }

        // Handle breeding phase
        function performBreeding() {
            addLog("--- 번식 단계 시작 ---");
            let bredThisTurn = false;
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const quadrat = gameState.board[r][c];
                    const p1NonParasites = quadrat.pieces.filter(p => p.playerId === 1 && !p.isParasite);
                    const p2NonParasites = quadrat.pieces.filter(p => p.playerId === 2 && !p.isParasite);

                    // Check breeding conditions for Player 1
                    if (p1NonParasites.length >= 2 && p2NonParasites.length === 0) {
                        if (addPieceToBoardFromPool(gameState.player1, 1, r, c, false)) { // Attempt to add adaptation 1 piece
                             addLog(`칸 (${r},${c})에서 플레이어 1 번식 성공.`);
                             bredThisTurn = true;
                        }
                    // Check breeding conditions for Player 2
                    } else if (p2NonParasites.length >= 2 && p1NonParasites.length === 0) {
                        if (addPieceToBoardFromPool(gameState.player2, 1, r, c, false)) {
                            addLog(`칸 (${r},${c})에서 플레이어 2 번식 성공.`);
                            bredThisTurn = true;
                        }
                    }
                }
            }
            if (!bredThisTurn) addLog("이번 턴에 번식한 말이 없습니다.");
            addLog("--- 번식 단계 종료 ---");
            updateUI(); 
            
            // Transition to next turn's piece placement
            gameState.turnNumber++;
            showTransitionModal("다음 턴 준비", `턴 ${gameState.turnNumber}이 시작됩니다.\n플레이어 1에게 기기를 넘겨주세요.`, "플레이어 1 턴 시작", () => {
                gameState.currentPlayerId = 1; // Player 1 starts the new turn
                gameState.currentPhase = 'PLACE_PIECE';
                addLog(`\n--- 턴 ${gameState.turnNumber} 시작 ---`);
                addLog(`플레이어 1의 말 놓기 차례입니다.`);
                updateUI();
            });
        }
        
        // Check if the game over condition is met
        function checkGameOver() {
            // Game ends when both players have used all their 18 initial non-parasite pieces
            const p1AllPiecesUsed = gameState.player1.usedInitialPiecesCount >= PIECES_PER_PLAYER;
            const p2AllPiecesUsed = gameState.player2.usedInitialPiecesCount >= PIECES_PER_PLAYER;
            
            if (p1AllPiecesUsed && p2AllPiecesUsed) {
                 addLog("양쪽 플레이어 모든 초기 말 사용 (각각 18개). 게임 종료 조건 충족.");
                 return true;
            }
            return false;
        }

        // Calculate and display game results
        function displayGameResults() {
            gameState.currentPhase = 'GAME_OVER'; 
            gameState.currentPlayerId = 0; // Special ID to reveal all adaptations on board
            updateUI(); // Final render of the board

            let p1ScorePieces = 0;
            let p2ScorePieces = 0;
            let p1OccupiedQuadrats = new Set();
            let p2OccupiedQuadrats = new Set();
            let p1TotalAdaptation = 0;
            let p2TotalAdaptation = 0;

            // Calculate scores based on pieces on board and occupied quadrats
            gameState.board.forEach((row, r_idx) => {
                row.forEach((quadrat, c_idx) => {
                    let p1HasPieceInQuad = false;
                    let p2HasPieceInQuad = false;
                    quadrat.pieces.forEach(piece => { // Iterate over pieces in each quadrat
                        if (piece.playerId === 1) {
                            p1ScorePieces++; 
                            p1TotalAdaptation += piece.adaptation;
                            p1HasPieceInQuad = true;
                        } else { // piece.playerId === 2
                            p2ScorePieces++;
                            p2TotalAdaptation += piece.adaptation;
                            p2HasPieceInQuad = true;
                        }
                    });
                    if (p1HasPieceInQuad) p1OccupiedQuadrats.add(`${r_idx},${c_idx}`); // Add to set of occupied quadrats
                    if (p2HasPieceInQuad) p2OccupiedQuadrats.add(`${r_idx},${c_idx}`);
                });
            });

            const p1FinalScore = p1ScorePieces + p1OccupiedQuadrats.size; // Total score = piece count + occupied quadrat count
            const p2FinalScore = p2ScorePieces + p2OccupiedQuadrats.size;

            // Prepare result text
            let resultText = `플레이어 1: 총 ${p1FinalScore}점 (말 ${p1ScorePieces}개 + 점령칸 ${p1OccupiedQuadrats.size}개)\n`;
            resultText += `총 적응도 합: ${p1TotalAdaptation}\n\n`;
            resultText += `플레이어 2: 총 ${p2FinalScore}점 (말 ${p2ScorePieces}개 + 점령칸 ${p2OccupiedQuadrats.size}개)\n`;
            resultText += `총 적응도 합: ${p2TotalAdaptation}\n\n`;

            // Determine winner
            let winnerMessage = "";
            if (p1FinalScore > p2FinalScore) winnerMessage = "플레이어 1 승리!";
            else if (p2FinalScore > p1FinalScore) winnerMessage = "플레이어 2 승리!";
            else { // Tie in score, compare total adaptation
                if (p1TotalAdaptation > p2TotalAdaptation) winnerMessage = "플레이어 1 승리! (동점 시 적응도 총합 우세)";
                else if (p2TotalAdaptation > p1TotalAdaptation) winnerMessage = "플레이어 2 승리! (동점 시 적응도 총합 우세)";
                else winnerMessage = "무승부!";
            }
            resultText += `결과: ${winnerMessage}`;
            
            addLog("--- 게임 결과 ---");
            addLog(resultText.replace(/\n\n/g, '\n')); // Log condensed result
            
            // Show result modal with option to start a new game
            showTransitionModal("게임 종료", resultText, "새 게임 시작", () => {
                initializeGame(); // Restart the game
            });
        }

        // --- Start Game ---
        initializeGame(); // Initialize and start the first game
    </script>
</body>
</html>
